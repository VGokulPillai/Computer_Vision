# -*- coding: utf-8 -*-
"""CV_Depth_and_Image_Differencing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FC44MJPJJvRQORNel0Y6F9kbD_1S-2K2
"""

# Tutorial 8
# Finding depth

# Along camera axis
# When focal length and pixel size is given

cameraVelocity = 0.1
focalLength_milli = 35
pixelSize_milli = 0.1

# Convert from mm to metres
pixelSize = 0.1 / 100
focalLength = 35 / 100

# X-coordinate of point at t
point_1_x = 25

#x of point at t+1
point_2_x = 50

velocity_pixels = point_1_x - point_2_x / 1
velocity_mps = pixelSize * velocity_pixels

depth = -(((focalLength)*cameraVelocity) / velocity_mps)

print(depth, "metres")

# Along optical axis
# When centre of image coordinates given
point_t1 = (50,70)
point_t_plus1 = (45,63)
centre = (100,140)
cameraVelocity = 0.1

# [0] = x-coordinate and [1] = y-coordinate

point_t1_centre = ((point_t1[0] - centre[0]), (point_t1[1] - centre[1]))

point_t_plus1_centre = ((point_t_plus1[0] - centre[0]), (point_t_plus1[1] - centre[1]))

velocity = (point_t_plus1_centre[0] - point_t1_centre[0]) / 1
depth = (point_t1_centre[0] * cameraVelocity)/velocity

print(depth, "metres")

# Finding time-to-collision
# Does not require the recovery of the depth of scene point
# x1/x

time_to_collision = point_t1_centre[0] / velocity
print(time_to_collision, "seconds")
#(From the answer to the previous question, we know that the camera is 1m from the point and moving at 0.1msâˆ’1, so this agrees with the result above.)

# Image differencing
# Background subtraction
import numpy as np 

frame1 = [190, 200, 90, 110, 90]
frame2 = [110, 170, 160, 70, 70]
frame3 = [100, 60, 170, 200, 90]
frame4 = [90, 100, 100, 190, 190]
frames = [frame1, frame2, frame3, frame4]

threshold = 50

def differencing(frame1, frame2):
  return [abs(frame1[i] - frame2[i]) for i in range(len(frame1))]


for i in range(len(frames)-1):
  diff = differencing(frames[i], frames[i+1])
  print("diff: ", diff)
  np_diff = np.array(diff)
  print("diff thresh: ", np_diff > threshold)


def background(frames):
  B = np.zeros(len(frames[0]))
  beta = 0.5
  for i in range(len(frames)):
    print("t", i+1)
    # Calculate background (moving average)
    B = (1 - beta)*B + (beta*np.array(frames[i]))
    print(" B: ", B)

    # Subtract background
    background_subtract = abs(frames[i] - B)
    print("frame - B:", background_subtract)
    print("threshold: ", background_subtract > threshold)

background(frames)

